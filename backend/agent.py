#!/usr/bin/env python3
"""
Backtesting NLP Engine using Dedalus AI Agent
==============================================

This script demonstrates a complete workflow for backtesting trading strategies:
1. Parse natural language strategy descriptions
2. Fetch historical stock data from yfinance
3. Generate backtesting Python scripts dynamically
4. Execute backtests and analyze results
5. Answer follow-up questions about metrics

The agent automatically chains these tools together based on the user's request.
"""

import asyncio
import json
import os
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Dict, Any

import pandas as pd
import yfinance as yf
from dedalus_labs import AsyncDedalus, DedalusRunner
from dotenv import load_dotenv

# Load environment variables
load_dotenv()


# ============================================================================
# TOOL 1: Fetch Stock Data
# ============================================================================

def fetch_stock_data(ticker: str, start_date: str, end_date: str) -> str:
    """
    Fetch historical stock data from Yahoo Finance and save it to a CSV file.
    
    Args:
        ticker: Stock ticker symbol (e.g., 'SPY', 'GOOGL')
        start_date: Start date in YYYY-MM-DD format
        end_date: End date in YYYY-MM-DD format
    
    Returns:
        JSON string containing the file path and basic data statistics
    """
    try:
        print(f"\n[TOOL: fetch_stock_data] Fetching {ticker} data from {start_date} to {end_date}...")
        
        # Download data
        df = yf.download(ticker, start=start_date, end=end_date, progress=False)
        
        if df.empty:
            return json.dumps({
                "error": f"No data found for ticker {ticker}",
                "success": False
            })
        
        # Flatten MultiIndex columns if present
        if isinstance(df.columns, pd.MultiIndex):
            df.columns = df.columns.get_level_values(0)
        
        # Ensure we have the required columns
        required_cols = ['Open', 'High', 'Low', 'Close', 'Volume']
        df = df[required_cols]
        
        # Save to temporary file
        data_dir = Path(tempfile.gettempdir()) / "backtest_data"
        data_dir.mkdir(exist_ok=True)
        
        file_path = data_dir / f"{ticker}_{start_date}_{end_date}.csv"
        df.to_csv(file_path)
        
        # Calculate statistics
        stats = {
            "success": True,
            "file_path": str(file_path),
            "ticker": ticker,
            "start_date": start_date,
            "end_date": end_date,
            "total_rows": len(df),
            "date_range": {
                "first": df.index[0].strftime('%Y-%m-%d'),
                "last": df.index[-1].strftime('%Y-%m-%d')
            },
            "price_range": {
                "min": float(df['Close'].min()),
                "max": float(df['Close'].max()),
                "mean": float(df['Close'].mean())
            }
        }
        
        print(f"[TOOL: fetch_stock_data] ✓ Data saved to {file_path}")
        print(f"[TOOL: fetch_stock_data] ✓ {len(df)} rows fetched")
        
        return json.dumps(stats, indent=2)
        
    except Exception as e:
        error_result = {
            "error": str(e),
            "success": False
        }
        print(f"[TOOL: fetch_stock_data] ✗ Error: {e}")
        return json.dumps(error_result)


# ============================================================================
# TOOL 2: Generate Backtest Script
# ============================================================================

def generate_backtest_script(
    strategy_description: str,
    data_file_path: str,
    ticker: str
) -> str:
    """
    Generate a Python backtesting script based on the strategy description.
    
    Args:
        strategy_description: Natural language description of the trading strategy
        data_file_path: Path to the CSV file containing stock data
        ticker: Stock ticker symbol for reference
    
    Returns:
        JSON string containing the script file path and script preview
    """
    try:
        print(f"\n[TOOL: generate_backtest_script] Generating script for strategy...")
        
        # Create a template-based script that can be customized
        # Use forward slashes to avoid Windows backslash issues
        data_path_safe = data_file_path.replace('\\', '/')
        script_template = f'''"""
Backtesting Script - Generated by Dedalus AI Agent
====================================================
Strategy: {strategy_description}
Ticker: {ticker}
Data: {data_path_safe}
"""

from backtesting import Strategy, Backtest
from backtesting.lib import crossover
import talib
import pandas as pd

class CustomStrategy(Strategy):
    # Strategy parameters (can be optimized later)
    sma_short = 50
    sma_long = 200
    rsi_period = 14
    rsi_overbought = 70
    rsi_oversold = 30
    
    def init(self):
        close = self.data.Close
        
        # Calculate technical indicators
        self.sma_short_line = self.I(talib.SMA, close, self.sma_short)
        self.sma_long_line = self.I(talib.SMA, close, self.sma_long)
        self.rsi = self.I(talib.RSI, close, self.rsi_period)
    
    def next(self):
        # BUY LOGIC: Golden Cross (SMA short crosses above SMA long)
        if crossover(self.sma_short_line, self.sma_long_line):
            if not self.position:
                self.buy(size=0.95)  # Use 95% of available cash
                print(f"BUY SIGNAL at {{self.data.index[-1]}}: Price={{self.data.Close[-1]:.2f}}")
        
        # SELL LOGIC: Death Cross OR RSI overbought
        elif self.position:
            # Condition 1: Death Cross (SMA short crosses below SMA long)
            if crossover(self.sma_long_line, self.sma_short_line):
                self.position.close()
                print(f"SELL SIGNAL (Death Cross) at {{self.data.index[-1]}}: Price={{self.data.Close[-1]:.2f}}")
            
            # Condition 2: RSI is overbought
            elif self.rsi[-1] > self.rsi_overbought:
                self.position.close()
                print(f"SELL SIGNAL (RSI Overbought) at {{self.data.index[-1]}}: Price={{self.data.Close[-1]:.2f}}, RSI={{self.rsi[-1]:.2f}}")


def run_backtest():
    """Load data, run backtest, and display results."""
    
    # Load data
    data_path = r"{data_file_path}"
    print(f"Loading data from {{data_path}}...")
    df = pd.read_csv(data_path, index_col=0, parse_dates=True)
    
    # Verify required columns
    required_cols = ['Open', 'High', 'Low', 'Close', 'Volume']
    if not all(col in df.columns for col in required_cols):
        raise ValueError(f"Data must contain columns: {{required_cols}}")
    
    print(f"Data loaded: {{len(df)}} rows from {{df.index[0]}} to {{df.index[-1]}}")
    
    # Analyze crossover opportunities
    print("\\nAnalyzing technical indicators...")
    sma_short = pd.Series(talib.SMA(df['Close'].values, 50), index=df.index)
    sma_long = pd.Series(talib.SMA(df['Close'].values, 200), index=df.index)
    
    golden_crosses = ((sma_short > sma_long) & (sma_short.shift(1) <= sma_long.shift(1))).sum()
    death_crosses = ((sma_short < sma_long) & (sma_short.shift(1) >= sma_long.shift(1))).sum()
    
    print(f"Golden Crosses (potential buy signals): {{golden_crosses}}")
    print(f"Death Crosses (potential sell signals): {{death_crosses}}")
    
    # Run backtest
    print("\\nRunning backtest...")
    bt = Backtest(
        df, 
        CustomStrategy,
        cash=10000,           # Starting cash
        commission=0.002,     # 0.2% commission per trade
        exclusive_orders=True
    )
    
    stats = bt.run()
    
    # Display results
    print("\\n" + "="*70)
    print("BACKTEST RESULTS")
    print("="*70)
    print(stats)
    print("="*70)
    
    # Key metrics summary
    print("\\nKEY PERFORMANCE METRICS:")
    print(f"  Total Return: {{stats['Return [%]']:.2f}}%")
    print(f"  Buy & Hold Return: {{stats['Buy & Hold Return [%]']:.2f}}%")
    print(f"  Max Drawdown: {{stats['Max. Drawdown [%]']:.2f}}%")
    print(f"  Sharpe Ratio: {{stats['Sharpe Ratio']:.2f}}")
    print(f"  # Trades: {{stats['# Trades']}}")
    print(f"  Win Rate: {{stats['Win Rate [%]']:.2f}}%")
    
    # Save plot
    print("\\nGenerating performance chart...")
    try:
        plot_path = r"{data_file_path}".replace('.csv', '_results.html')
        bt.plot(filename=plot_path, open_browser=False)
        print(f"Chart saved to: {{plot_path}}")
    except Exception as e:
        print(f"Could not generate plot: {{e}}")
    
    return stats


if __name__ == "__main__":
    try:
        stats = run_backtest()
    except Exception as e:
        print(f"Error running backtest: {{e}}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
'''
        
        # Save script to temporary file
        script_dir = Path(tempfile.gettempdir()) / "backtest_scripts"
        script_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        script_path = script_dir / f"backtest_{ticker}_{timestamp}.py"
        
        with open(script_path, 'w') as f:
            f.write(script_template)
        
        result = {
            "success": True,
            "script_path": str(script_path),
            "ticker": ticker,
            "preview": script_template[:500] + "...",  # First 500 chars
            "strategy_summary": strategy_description
        }
        
        print(f"[TOOL: generate_backtest_script] ✓ Script saved to {script_path}")
        
        return json.dumps(result, indent=2)
        
    except Exception as e:
        error_result = {
            "error": str(e),
            "success": False
        }
        print(f"[TOOL: generate_backtest_script] ✗ Error: {e}")
        return json.dumps(error_result)


# ============================================================================
# TOOL 3: Execute Backtest Script
# ============================================================================

def execute_backtest(script_path: str) -> str:
    """
    Execute a Python backtesting script and capture its output.
    
    Args:
        script_path: Path to the Python script to execute
    
    Returns:
        JSON string containing execution results, output, and any errors
    """
    try:
        print(f"\n[TOOL: execute_backtest] Executing backtest script...")
        print(f"[TOOL: execute_backtest] Script: {script_path}")
        
        # Execute the script
        result = subprocess.run(
            [sys.executable, script_path],
            capture_output=True,
            text=True,
            timeout=60  # 60 second timeout
        )
        
        execution_result = {
            "success": result.returncode == 0,
            "script_path": script_path,
            "return_code": result.returncode,
            "stdout": result.stdout,
            "stderr": result.stderr if result.stderr else None,
            "execution_time": "< 60s"
        }
        
        if result.returncode == 0:
            print(f"[TOOL: execute_backtest] ✓ Execution successful")
            print(f"\n{'-'*70}")
            print("BACKTEST OUTPUT:")
            print(f"{'-'*70}")
            print(result.stdout)
            print(f"{'-'*70}\n")
        else:
            print(f"[TOOL: execute_backtest] ✗ Execution failed with return code {result.returncode}")
            print(f"Error: {result.stderr}")
        
        return json.dumps(execution_result, indent=2)
        
    except subprocess.TimeoutExpired:
        error_result = {
            "error": "Script execution timed out (>60 seconds)",
            "success": False,
            "script_path": script_path
        }
        print(f"[TOOL: execute_backtest] ✗ Timeout")
        return json.dumps(error_result)
        
    except Exception as e:
        error_result = {
            "error": str(e),
            "success": False,
            "script_path": script_path
        }
        print(f"[TOOL: execute_backtest] ✗ Error: {e}")
        return json.dumps(error_result)


# ============================================================================
# TOOL 4: Explain Backtest Metrics
# ============================================================================

def explain_metric(metric_name: str, metric_value: str) -> str:
    """
    Provide detailed explanations of backtesting metrics.
    
    Args:
        metric_name: Name of the metric to explain
        metric_value: Value of the metric from the backtest
    
    Returns:
        Detailed explanation of the metric and its interpretation
    """
    explanations = {
        "return": """
Total Return [%]: This is the overall percentage gain or loss of your strategy from start to finish.
- A positive value means your strategy made money
- A negative value means your strategy lost money
- Compare this to Buy & Hold Return to see if active trading was worthwhile
        """,
        "buy_hold": """
Buy & Hold Return [%]: This is how much you would have made by simply buying the asset at the start and holding until the end.
- Serves as a benchmark for your strategy
- If your strategy return > Buy & Hold, your active trading added value
- If your strategy return < Buy & Hold, you would have been better off holding
        """,
        "sharpe": """
Sharpe Ratio: Measures risk-adjusted return. Higher is better!
- Above 1.0: Good performance
- Above 2.0: Very good performance
- Above 3.0: Excellent performance
- Negative: Strategy lost money
Formula: (Return - Risk-Free Rate) / Standard Deviation
        """,
        "drawdown": """
Max Drawdown [%]: The largest peak-to-trough decline during the backtest.
- Shows the worst possible loss you would have experienced
- Important for risk management and psychology
- Lower drawdown = less stressful trading
Example: 20% drawdown means at worst, your account dropped 20% from its highest point
        """,
        "win_rate": """
Win Rate [%]: Percentage of trades that were profitable.
- 50%+ is generally considered good
- You can still be profitable with <50% win rate if your wins are bigger than losses
- Should be combined with profit factor and average trade analysis
        """,
        "trades": """
Number of Trades [#]: Total number of completed trades during the backtest.
- Too few trades: May not have enough data to validate strategy
- Too many trades: Higher transaction costs
- Consider if the sample size is statistically significant
        """
    }
    
    metric_lower = metric_name.lower()
    explanation = "No specific explanation available for this metric."
    
    for key, value in explanations.items():
        if key in metric_lower:
            explanation = value
            break
    
    result = f"""
METRIC: {metric_name}
VALUE: {metric_value}

EXPLANATION:
{explanation}
"""
    
    print(f"[TOOL: explain_metric] Explaining {metric_name}")
    return result


# ============================================================================
# Main Execution
# ============================================================================

async def main():
    """
    Main execution function for the backtesting engine.
    """
    
    print("="*70)
    print("BACKTESTING NLP ENGINE - Powered by Dedalus AI")
    print("="*70)
    
    # Hardcoded strategy for testing
    # You can change this to test different strategies
    STRATEGY = """
    Volatility-based strategy using Bollinger Bands.

Entry Rules:
- Buy when price touches lower Bollinger Band
- Confirm with RSI below 40
- Volume should be above 20-day average

Exit Rules:
- Sell when price touches upper Bollinger Band
- OR sell when RSI exceeds 65
- OR sell on 3% stop loss

Parameters:
- Ticker: TSLA
- Date Range: 2020-06-01 to 2023-12-31
- Starting Capital: $20,000
- Commission: 0.25% per trade
- Bollinger Bands: 20-period, 2 standard deviations
    """
    
    print(f"\nSTRATEGY TO BACKTEST:")
    print(f"{'-'*70}")
    print(STRATEGY)
    print(f"{'-'*70}\n")
    
    # Initialize Dedalus
    try:
        client = AsyncDedalus()
        runner = DedalusRunner(client)
        
        # Run the agent with tool chaining
        print("Initializing Dedalus AI Agent...")
        print("The agent will automatically:")
        print("  1. Parse the strategy description")
        print("  2. Fetch historical stock data")
        print("  3. Generate a backtesting script")
        print("  4. Execute the backtest")
        print("  5. Analyze and present results")
        print()
        
        result = await runner.run(
            input=f"""
You are a quantitative trading analyst. Analyze and backtest this trading strategy:

{STRATEGY}

Please:
1. First, use fetch_stock_data to get the historical data for SPY from 2020-01-01 to 2023-01-01
2. Then use generate_backtest_script to create a Python backtesting script based on the strategy
3. Finally, use execute_backtest to run the script and show me the results

After the backtest runs, provide a summary of the key findings and whether this strategy would have been profitable.
            """,
            model="openai/gpt-4.1",  # GPT-4.1 is better at complex tool chaining
            tools=[
                fetch_stock_data,
                generate_backtest_script,
                execute_backtest,
                explain_metric
            ],
            stream=False
        )
        
        print("\n" + "="*70)
        print("AGENT ANALYSIS & SUMMARY")
        print("="*70)
        print(result.final_output)
        print("="*70)
        
        # Optional: Interactive Q&A mode
        print("\n" + "="*70)
        print("Interactive Q&A Mode")
        print("="*70)
        print("You can now ask follow-up questions about the results.")
        print("Examples:")
        print("  - 'What does Sharpe Ratio mean?'")
        print("  - 'How do I interpret the drawdown?'")
        print("  - 'Was this strategy better than buy and hold?'")
        print("Type 'exit' to quit.")
        print()
        
        while True:
            question = input("Your question: ").strip()
            
            if question.lower() in ['exit', 'quit', 'q']:
                print("Goodbye!")
                break
            
            if not question:
                continue
            
            # Answer follow-up questions
            follow_up = await runner.run(
                input=f"""
Based on the previous backtest results, answer this question:
{question}

Use the explain_metric tool if the question is about specific metrics.
                """,
                model="openai/gpt-4.1",
                tools=[explain_metric],
                stream=False
            )
            
            print(f"\nAnswer: {follow_up.final_output}\n")
        
    except Exception as e:
        print(f"\n✗ Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    # Check for required API key
    if not os.getenv("DEDALUS_API_KEY"):
        print("Error: DEDALUS_API_KEY environment variable not set")
        print("Please add it to your .env file or set it in your environment")
        sys.exit(1)
    
    asyncio.run(main())
